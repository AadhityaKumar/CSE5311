tree-search(x,k)
    if x == null or k == x.key
        return x
    if k < x.key
        return tree-search(x.left, k)
    else
        return tree-search(x.right, k)

tree-search-it(x, k)
    while(k != x.key and x != null)
        if k < x.key
            x = x.left
        else
            x = x.right
    return x

Tree-max(x)
    while(x.right != null)
        x = x.right
    return x

Tree-min(x)
    while(x.left != null)
        x = x.left
    return x

Tree-insert(T, z)
    y = null
    x = T.root
    while (x != null)
        y = x
        if z.key < x.key
            x = x.left
        else
            x = x.right
    z.p = y
    if y == null
        T.root = z
    elif y.key < z.key
        y.right = z.key
    else
        y.left = z.key

tree-sort(A)
    for i = 1 to len(A)
        tree-insert(A[i])
    inorder_walk(root)

tree_successor(x)
    if x.right != null
        return min(x.right)
    y = x.p
    while y != null and x == y.right
        x = y
        y = y.p
    return y

Tree_delete(T, z)
    if z.left == null
        Transplant(T, z, z.right)
    if z.right == null
        Transplant(T, z, z.left)
    else
        y = Tree-min(z.right)
        if y.p != z
            Transplant(T, y, y.right)
            y.right = z.right
            y.right.p = y
        Transplant(T, z, y.left)
        y.left = z.left
        y.left.p = y

Transplant(T, u, v)
    if u.p == null
        T.root = v
    elif u = u.p.left
        u.p.left = v
    else
        u.p.right = v
    if v != null
        v.p = u.p

Cut-Rod(p, n)
    if n == 0
        return 0
    q = -infinty
    for i = 1 to n
        q = max(q, p[i] + Cut-Rod(p, n-i))
    return q

Memoized_Cut-Rod(p, n)
    r = [0...n]
    for i = 0 to n
        r[i] = -infinty
    return Memoized_Cut-Rod-Aux(p, n, r)

Memoized_Cut-Rod-Aux(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else
        q = -infinity
        for i = 0 to n
            q = max(q, p[i] + Memoized_Cut-Rod-Aux(p, n-i, r))
    r[n] = q
    return q

Bottom_up_cut_rod(p, n)
    r = [0 ... n]
    r[0] = 0
    for j = 1 to n
        q = -infinity
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

Bottom_up_cut_rod_extended(p, n)
    r = [0...n]
    s = [0...n]
    r[0] = 0
    for j = 1 to n
        q = -infinity
        for i = 1 to j
            if q < p[i] + r[j-i]
                q = p[i] + r[j-i]
                s[j] = i
        r[j] = q
    return r and s

Knapsack(w, b, W)
    n = len(w)
    B = [0...n, 0...W]
    for k = 0 to n
        for c = 0 to W
            if c == 0 or k == 0
                B[k, c] = 0
            elif w[k] <= c
                B[k, c] = max(B[k-1, c], b[k] + B[k-1, c - w[k]])
            else
                B[k, c] = B[k-1, c]
    return B[n, W]

Knapsack_items(B, n, W)
    i = n
    k = W
    selected_items = []
    while i > 0 and k > 0
        if B[i, k] != B[i-1, k]
            selected_items.append(i)
            i = i - 1
            k = k - w[i]
        else
            i = i - 1
    return selected_items

Matrix_mul(A, B)
    if A.col != B.row
        error: incorrect dimensions
    else
        setup(C, A.row, B.col)
    for i = 1 to A.row
        for j = 1 to B.col
            c[i][j] = 0
            for k = 1 to A.col
                c[i][j] = c[i][j] + A[i][k] * c[k][j]
    return C

Matrix_chain_order(p)
    n = len(p) - 1
    m = [1...n, 1...n]
    s = [1...n, 1...n]
    for i = 1 to n
        m[i, i] = 0
    for l = 2 to n
        for i = 1 to n-l+1
            j = i + l - 1
            m[i, j] = infinity
            for k = i to j-1
                q = m[i, k] + m[k+1, j] + p[i-1]*p[k]*p[j]
                if q < m[i,j]
                    m[i, j] = q
                    s[i, j] = k
    return m and s